1. 总体设计思路
   POJO层：定义数据的载体。我们需要一个对象来存小说内容（Novel），还需要一个对象来存统计结果（AnalysisResult）。
   Service层：核心业务逻辑。负责读取文件、清洗数据、执行计数算法、执行共现算法。
   Controller层：接收用户的指令（比如“加载文件”、“查询主角”），调用 Service，并将结果返回给界面（或控制台）。
2. 代码实现
   A. POJO 层 (Data Transfer Objects)
   我们需要两个类：一个代表小说本身，一个代表分析结果。
1. Novel.java (小说实体)
   用来在内存中缓存小说内容，避免每次查询都重新读硬盘。
   code
   Java
   import java.util.List;

public class Novel {
private String fileName;
private String filePath;
// 核心数据：将小说按段落存储。
// 为什么按段落？因为“共现”通常定义为“出现在同一段落”。
private List<String> paragraphs;

    public Novel(String fileName, String filePath, List<String> paragraphs) {
        this.fileName = fileName;
        this.filePath = filePath;
        this.paragraphs = paragraphs;
    }

    public List<String> getParagraphs() {
        return paragraphs;
    }
    
    // Getter, Setter, toString...
}
2. CharacterStat.java (统计结果实体)
   用来封装查询后的数据，方便Controller展示。
   code
   Java
   public class CharacterStat {
   private String name;          // 角色名
   private int totalCount;       // 出现总次数
   // 关联统计：Key是另一个角色名，Value是共同出现的次数
   private String relatedName;   
   private int coOccurrenceCount;

   public CharacterStat(String name, int totalCount) {
   this.name = name;
   this.totalCount = totalCount;
   }

   // 用于同时设置共现数据的构造
   public CharacterStat(String name, int totalCount, String relatedName, int coOccurrenceCount) {
   this.name = name;
   this.totalCount = totalCount;
   this.relatedName = relatedName;
   this.coOccurrenceCount = coOccurrenceCount;
   }

   @Override
   public String toString() {
   if (relatedName == null) {
   return String.format("角色 [%s] 出现了 %d 次", name, totalCount);
   } else {
   return String.format("角色 [%s] 出现了 %d 次; 与 [%s] 同框 %d 次",
   name, totalCount, relatedName, coOccurrenceCount);
   }
   }
   // Getters...
   }
   B. Service 层 (Business Logic)
   这里是程序最“聪明”的地方。使用了之前优化的文件读取逻辑。
   NovelService.java
   code
   Java
   import java.io.IOException;
   import java.nio.charset.StandardCharsets;
   import java.nio.file.Files;
   import java.nio.file.Paths;
   import java.util.List;
   import java.util.stream.Collectors;

public class NovelService {

    private Novel currentNovel;

    /**
     * 1. 加载小说
     * 使用 Java 8 Streams 读取并过滤空行，每行视为一段
     */
    public void loadNovel(String filePath) throws IOException {
        // 读取所有行，去除首尾空格，并过滤掉空行（空行对统计没意义）
        List<String> paragraphs = Files.lines(Paths.get(filePath), StandardCharsets.UTF_8)
                .map(String::trim)
                .filter(line -> !line.isEmpty())
                .collect(Collectors.toList());

        String fileName = Paths.get(filePath).getFileName().toString();
        this.currentNovel = new Novel(fileName, filePath, paragraphs);
    }

    /**
     * 2. 核心算法：统计单个角色出现次数
     */
    public int countCharacter(String name) {
        checkNovelLoaded();
        int count = 0;
        for (String paragraph : currentNovel.getParagraphs()) {
            // 简单包含判断。进阶可以使用正则表达式 countMatches 防止匹配到类似名字
            if (paragraph.contains(name)) {
                // 这是一个段落出现一次就算一次？还是段落里出现多次算多次？
                // 这里假设：只要段落里提到了，就算该段落是一个“出现场景”
                count++;
                
                // 如果要统计绝对词频（一段里出现3次算3次），需要稍微复杂的正则分割
            }
        }
        return count;
    }

    /**
     * 3. 核心算法：统计两个角色共现次数 (在同一段落)
     */
    public int countCoOccurrence(String name1, String name2) {
        checkNovelLoaded();
        int count = 0;
        for (String paragraph : currentNovel.getParagraphs()) {
            // 同时包含两个名字
            if (paragraph.contains(name1) && paragraph.contains(name2)) {
                count++;
            }
        }
        return count;
    }

    // 辅助检查方法
    private void checkNovelLoaded() {
        if (this.currentNovel == null) {
            throw new IllegalStateException("请先加载小说文件！");
        }
    }
    
    // 获取当前小说名
    public String getNovelName() {
        return currentNovel != null ? currentNovel.getFileName() : "未加载";
    }
}
C. Controller 层 (Interaction)
Controller 负责协调。它不处理具体算法，只负责接收参数，调用 Service，组装 POJO 返回。
NovelController.java
code
Java
import java.io.IOException;

public class NovelController {

    private NovelService novelService;

    public NovelController() {
        // 手动注入 Service
        this.novelService = new NovelService();
    }

    /**
     * 处理“打开文件”请求
     */
    public String handleOpenFile(String filePath) {
        try {
            novelService.loadNovel(filePath);
            return "成功加载小说: " + novelService.getNovelName();
        } catch (IOException e) {
            e.printStackTrace();
            return "加载失败: 文件不存在或无法读取";
        }
    }

    /**
     * 处理“分析单个角色”请求
     */
    public CharacterStat handleAnalyzeOne(String name) {
        try {
            int count = novelService.countCharacter(name);
            return new CharacterStat(name, count);
        } catch (IllegalStateException e) {
            System.err.println(e.getMessage());
            return null;
        }
    }

    /**
     * 处理“分析角色关系”请求
     */
    public CharacterStat handleAnalyzeRelation(String mainRole, String targetRole) {
        try {
            // 1. 获取主角总数
            int mainCount = novelService.countCharacter(mainRole);
            // 2. 获取共现数
            int coCount = novelService.countCoOccurrence(mainRole, targetRole);
            
            return new CharacterStat(mainRole, mainCount, targetRole, coCount);
        } catch (IllegalStateException e) {
            System.err.println(e.getMessage());
            return null;
        }
    }
}
D. 模拟客户端 (org.miner.Main)
这是一个简单的控制台调用示例，你可以把它换成 Swing 的按钮点击事件。
code
Java
public class AppMain {
public static void main(String[] args) {
// 1. 初始化控制器
NovelController controller = new NovelController();

        // 2. 模拟用户选择文件 (这里换成你之前写的 JFileChooser 获取到的路径)
        String path = "C:/Books/西游记.txt"; 
        System.out.println(controller.handleOpenFile(path));

        // 3. 模拟用户输入角色 "孙悟空"
        CharacterStat stat1 = controller.handleAnalyzeOne("孙悟空");
        System.out.println("分析结果: " + stat1);

        // 4. 模拟用户想看 "孙悟空" 和 "猪八戒" 的关系
        CharacterStat stat2 = controller.handleAnalyzeRelation("孙悟空", "猪八戒");
        System.out.println("关系分析: " + stat2);
    }
}
3. 优化的方向（供参考）
   模糊匹配问题：
   目前的 contains("李") 会匹配到 "李白"、"行李"。
   改进：在 Service 层引入正则表达式（Regex），或者使用分词库（如 Ansj、HanLP）来做精准的人名识别。
   性能问题：
   目前每次查询都会遍历整个 List<String>。如果小说有几百万字，查询会变慢。
   改进：可以在 loadNovel 时建立一个 倒排索引 (Inverted Index)。
   Map<String, List<Integer>>: 键是人名，值是该人名出现过的段落索引号列表。
   这样查询共现时，只需要取两个列表的交集，速度会快非常多。
   段落识别：
   目前假设文件的一行就是一个段落。有些txt文件是硬回车的（一行只有30字），这时候需要写逻辑把碎行拼接成完整的自然段。
   这个架构（POJO + Service + Controller）清晰地分离了数据、逻辑和交互，后续如果你要加上图形界面（Swing/JavaFX）或者换成 Web 接口，只需要改动 Controller 的调用方式即可，业务逻辑完全不用变。